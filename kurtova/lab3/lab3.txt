EOL EQU '$

;----------Стек программы----------
AStack SEGMENT STACK
DW 32 DUP(?)
AStack ENDS

;----------Данные программы--------
DATA SEGMENT
buffer DB 128 DUP(?)
a DW 3
b DW -5
i DW -2
k DW 1
i1 DW ?
i2 DW ?
res DW ?
DATA ENDS

;----------Код программы-----------
CODE SEGMENT
ASSUME CS:CODE, DS:DATA, SS:AStack

;--------Головная процедура--------
Main PROC FAR
	push ds
	sub ax, ax
	push ax
	mov ax, DATA
	mov ds, ax
	
f1:			; Вычисляем f1
	mov ax, i   
	shl ax, 1 	; Умножаем i на 4
	shl ax, 1
	mov bx, a
	cmp bx, b	; Сравниваем a и b
	jle f1_case2 	; Если a <= b, перейти к f2_case2

f1_case1: 		; a > b
	add ax, 3	; 4i + 3
	neg ax
	mov cx, ax 	; cx: -4i - 3
	jmp f1_end
	
f1_case2: 		; a <= b
	mov bx, ax 	; bx = ax = 4i
	shr bx, 1	; bx = 2i
	add ax, bx	; ax = 4i + 2i = 6i
	mov cx, ax	; cx = 6i
	sub cx, 10	; cx = 6i - 10

f1_end:
	mov i1, cx	; i1 = f1(a, b, i)


f2:			; Вычисляем f2
	mov ax, i
	mov bx, a
	cmp bx, b
	jle f2_case2	; Если a <= b, перейти к f2_case2

f2_case1:
	shl ax, 1	; Умножаем i на 4
	shl ax, 1
	sub ax, 5	; ax = 4i - 5
	neg ax		; ax = -4i + 5
	mov cx, ax
	jmp f2_end
		
f2_case2:
	mov bx, ax	; bx = i
	shl ax, 1	; ax = 2i
	add ax, bx 	; ax = 3i
	mov bx, ax	; bx = 3i
	mov ax, 10	; ax = 10
	sub ax, bx	; ax = 10 - 3i
	mov cx, ax
	
f2_end:
	mov i2, cx	
	
f3:			; Вычисляем f3
	mov bx, k
	cmp bx, 0
	jge f3_case2 	; Если k >= 0, перейти к f3_case2

f3_case1:
	mov ax, i1
	mov bx, i2
	sub ax, bx 	; i1-i2
	cmp ax, 0
	jl abs		; Если i1 - i2 < 0, найдём модуль выражения
	jmp min		; Больше 0, перейти к поиску минимального числа в паре
abs:
	neg ax

min: 
	mov bx, 2
	cmp ax, 2
	jle absmin 	; Если |i1 - i2| <= 2, перейти к absmin
twomin:
	mov cx, 2
	jmp f3_end
absmin: 
	mov cx, ax
	jmp f3_end	

f3_case2:
	mov ax, i2
	neg ax
	cmp ax, -6
	jge i2max	; Если -i2 >= -6, перейти к i2max
neg6max:
	mov cx, 6
	neg cx
	jmp f3_end
i2max:
	mov cx, ax	
f3_end:
	mov res, cx
	ret

Main ENDP
CODE ENDS
END Main